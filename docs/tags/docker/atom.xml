<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en_US"><generator uri="https://gohugo.io/" version="0.72.0">Hugo</generator><title type="html">docker on KevOps (%!s(&lt;nil>))</title><link href="https://kevingimbel.de/tags/docker/" rel="alternate" type="text/html" title="HTML"/><link href="https://kevingimbel.de/tags/docker/index.xml" rel="alternate" type="application/rss+xml" title="RSS"/><link href="https://kevingimbel.de/tags/docker/atom.xml" rel="self" type="application/atom+xml" title="Atom"/><link href="https://kevingimbel.de/de/tags/docker/" rel="alternate" type="text/html" hreflang="de" title="[%!s(<nil>)] HTML"/><link href="https://kevingimbel.de/de/tags/docker/index.xml" rel="alternate" type="application/rss+xml" hreflang="de" title="[%!s(<nil>)] RSS"/><link href="https://kevingimbel.de/de/tags/docker/atom.xml" rel="alternate" type="application/atom+xml" hreflang="de" title="[%!s(<nil>)] Atom"/><updated>2020-08-17T09:29:27+02:00</updated><id>https://kevingimbel.de/tags/docker/</id><entry><title type="html">Shipping Rust CLIs with Docker</title><link href="https://kevingimbel.de/blog/2020/08/shipping-rust-clis-with-docker/?utm_source=atom_feed" rel="alternate" type="text/html"/><link href="https://kevingimbel.de/project/license/?utm_source=atom_feed" rel="related" type="text/html" title="License"/><link href="https://kevingimbel.de/blog/2020/05/deno-1.0-released/?utm_source=atom_feed" rel="related" type="text/html" title="Deno 1.0 released"/><link href="https://kevingimbel.de/blog/2020/05/docker-apache-proxy-setup/?utm_source=atom_feed" rel="related" type="text/html" title="Docker Apache Proxy Setup"/><link href="https://kevingimbel.de/blog/2020/04/terrasave/?utm_source=atom_feed" rel="related" type="text/html" title="Terrasave"/><link href="https://kevingimbel.de/blog/2017/01/bash-script-ws/?utm_source=atom_feed" rel="related" type="text/html" title="Bash script: ws"/><id>https://kevingimbel.de/blog/2020/08/shipping-rust-clis-with-docker/</id><published>2020-08-06T00:00:00+00:00</published><updated>2020-08-06T00:00:00+00:00</updated><content type="html"><![CDATA[<p>I recently found a nice and clean way of building and distributing <a href="https://rust-lang.orf">Rust</a> CLI apps using <a href="https://www.docker.com/">docker</a>. For my work I created a Rust app that wraps some AWS SDK functions to make my day-to-day work with AWS easier. This CLI is very focused on the way we work at <a href="https://synoa.de/">Synoa</a> and therefore unfortunately not open source. The tech does not matter much, as we can just create a tiny example &ldquo;app&rdquo; for this blog post.</p>
<h2 id="rust-code">Rust code</h2>
<p>Below is the example Rust code we will use.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">use</span> std::env;

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> args: Vec<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> env::args().collect();
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;{:?}&#34;</span>, args);
}
</code></pre></div><p>This code only prints whatever arguments were passed to the script.</p>
<h2 id="building-the-binary---in-docker">Building the binary - in docker</h2>
<p>Next we will build the binary in docker using a &ldquo;<a href="https://docs.docker.com/develop/develop-images/multistage-build/#use-multi-stage-builds">multi-stage build</a>&rdquo; setup. This way we do not need to manage our local Rust environment, for example we don&rsquo;t need to keep our Rust targets up-to-date or make sure other contributors have the same environment setup - the compiling is all done inside Docker.</p>
<p>We start by declaring a <code>builder</code> container. This container is only used for compiling the binary.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Dockerfile" data-lang="Dockerfile"><span style="color:#66d9ef">FROM</span><span style="color:#e6db74"> clux/muslrust:1.45.0-stable as builder</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">WORKDIR</span><span style="color:#e6db74"> /volume</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">COPY</span> . .<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">RUN</span> cargo build --release<span style="color:#960050;background-color:#1e0010">
</span></code></pre></div><p>These four lines do the following:</p>
<ul>
<li>Create a container based on <a href="https://github.com/clux/muslrust"><code>clux/muslrust</code></a></li>
<li>Give it a name of <code>builder</code> (so we can reference it later)</li>
<li>Declare the working directory to be <code>/volume</code></li>
<li>Copy over all files from the current directory to <code>/volume</code></li>
<li>Run the <code>cargo build --release</code> command which builds our Rust binary</li>
</ul>
<h2 id="creating-the-docker-image">Creating the docker image</h2>
<p>Next, in the same Dockerfile, we declare the actual image. This is where we copy the compiled binary from the &ldquo;builder&rdquo; container.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Dockerfile" data-lang="Dockerfile"><span style="color:#66d9ef">FROM</span><span style="color:#e6db74"> alpine</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#75715e"># Copy the compiled binary from the builder container</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">COPY</span> --from<span style="color:#f92672">=</span>builder /volume/target/x86_64-unknown-linux-musl/release/docker-cli-sample .<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#75715e"># Pass all arguments etc to binary</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">ENTRYPOINT</span> [ <span style="color:#e6db74">&#34;/docker-cli-sample&#34;</span> ]<span style="color:#960050;background-color:#1e0010">
</span></code></pre></div><p>So what happens here?</p>
<ul>
<li>First with <code>FROM alpine</code> we use the slim <a href="https://alpinelinux.org/">Alpine Linux</a> as base image. Depending on what our binary is doing we could also use <code>FROM scratch</code> to not use a base image at all. For my case I chose Alpine because we needed to make HTTPS calls and they didn&rsquo;t work in a &ldquo;scratch&rdquo; image.</li>
<li><code>COPY</code> copies the binary from the builder container and places it in the root directory of our container</li>
<li><code>ENTRYPOINT [ &quot;/docker-cli-sample&quot; ]</code> means we execute the <code>docker-cli-sample</code> binary when we run the container</li>
</ul>
<p>All together, the Dockerfile looks like this.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Dockerfile" data-lang="Dockerfile"><span style="color:#66d9ef">FROM</span><span style="color:#e6db74"> clux/muslrust:1.45.0-stable as builder</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">WORKDIR</span><span style="color:#e6db74"> /volume</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">COPY</span> . .<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">RUN</span> cargo build --release<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">FROM</span><span style="color:#e6db74"> alpine</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">COPY</span> --from<span style="color:#f92672">=</span>builder /volume/target/x86_64-unknown-linux-musl/release/docker-cli-sample .<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">ENTRYPOINT</span> [ <span style="color:#e6db74">&#34;/docker-cli-sample&#34;</span> ]<span style="color:#960050;background-color:#1e0010">
</span></code></pre></div><h2 id="building-the-image-and-running-the-container">Building the image and running the container</h2>
<p>We can build the image now with the <code>docker build</code> command. Open a terminal and type:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">docker build -t kevingimbel/rust-docker-cli-sample:1.0 .  
</code></pre></div><p>Then run the image in a container. <code>--rm</code> makes sure the container is removed after it is executed, as we do not need it anymore.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ docker run --rm kevingimbel/rust-docker-cli-sample:1.0 -hello -world
<span style="color:#f92672">[</span><span style="color:#e6db74">&#34;/docker-cli-sample&#34;</span>, <span style="color:#e6db74">&#34;-hello&#34;</span>, <span style="color:#e6db74">&#34;-world&#34;</span><span style="color:#f92672">]</span>
</code></pre></div><h2 id="setting-up-the-cli-and-docker">Setting up the CLI and docker</h2>
<p>To execute this container like a CLI script we add the following to <code>~/.bashrc</code> (for Bash) or <code>~/.zshrc</code> (for zsh).</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">alias docker-rust-cli<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;docker run --rm kevingimbel/rust-docker-cli-sample:1.0&#39;</span>
</code></pre></div><p>Source the file by running the following, then test the command.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># bash</span>
source ~/.bashrc
<span style="color:#75715e"># zsh</span>
source ~/.zshrc
</code></pre></div><p>Now we can execute the command just like any other CLI. The arguments are all passed to the script, just as if it was a &ldquo;normal&rdquo; binary somewhere in our <code>$PATH</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ docker-rust-cli hello from docker
<span style="color:#f92672">[</span><span style="color:#e6db74">&#34;/docker-cli-sample&#34;</span>, <span style="color:#e6db74">&#34;hello&#34;</span>, <span style="color:#e6db74">&#34;from&#34;</span>, <span style="color:#e6db74">&#34;docker&#34;</span><span style="color:#f92672">]</span>
</code></pre></div><h2 id="advanced-volumes">Advanced: volumes</h2>
<p>We could end this post here, but there&rsquo;s one &ldquo;advanced&rdquo; topic I want to highlight: Volumes. If our script would create or download files we could not access them because they are only inside the container and the container. To prevent this we need to add a volume.</p>
<p>A volume can be added with <code>-v</code> in the docker command.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">alias docker-rust-cli<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;docker run --rm -v $(pwd):/cmd-root-dir kevingimbel/rust-docker-cli-sample:1.0&#39;</span>
</code></pre></div><h3 id="workdir"><code>WORKDIR</code></h3>
<p>Now we need to make sure that our cli app puts created files in the <code>/cmd-root-dir</code> directory. This can be done by specifying the <code>WORKDIR</code> in the Dockerfile. To do this we add a new line above <code>ENTRYPOINT</code> as shown below.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Dockerfile" data-lang="Dockerfile"><span style="color:#66d9ef">FROM</span><span style="color:#e6db74"> clux/muslrust:1.45.0-stable as builder</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">WORKDIR</span><span style="color:#e6db74"> /volume</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">COPY</span> . .<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">RUN</span> cargo build --release<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">FROM</span><span style="color:#e6db74"> alpine</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">COPY</span> --from<span style="color:#f92672">=</span>builder /volume/target/x86_64-unknown-linux-musl/release/docker-cli-sample .<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">WORKDIR</span><span style="color:#e6db74"> /cmd-root-dir</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">ENTRYPOINT</span> [ <span style="color:#e6db74">&#34;/docker-cli-sample&#34;</span> ]<span style="color:#960050;background-color:#1e0010">
</span></code></pre></div><p><code>WORKDIR</code> will create the directory if it doesn&rsquo;t exist. To test the changes, we can adjust the rust script to write to a file.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">use</span> std::env;
<span style="color:#66d9ef">use</span> std::fs;

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() -&gt; <span style="color:#a6e22e">std</span>::io::Result<span style="color:#f92672">&lt;</span>()<span style="color:#f92672">&gt;</span> {
    <span style="color:#66d9ef">let</span> args: Vec<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> env::args().collect();
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;{:?}&#34;</span>, args);
    fs::write(<span style="color:#e6db74">&#34;docker-cli-sample.log&#34;</span>, format<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Args: {:?}&#34;</span>, args))<span style="color:#f92672">?</span>;
    Ok(())
}
</code></pre></div><p>This will write the arguments into the <code>docker-cli-sample.log</code>. Because we set <code>WORKDIR</code> this will execute in the <code>/cmd-root-dir</code> inside the container. To actually get the log, we can now mount the volume with <code>-v</code> in our alias.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">alias docker-rust-cli<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;docker run --rm -v $(pwd):/cmd-root-dir kevingimbel/rust-docker-cli-sample:1.0&#39;</span>
</code></pre></div><p><code>$(pwd)</code> always evaluates to the current directory. This <strong>only works if</strong> we use sigle-quotes (<code>'</code>) in the alias!</p>
<p>So finally, running the command now will yield us the log in the current directory.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ docker-rust-cli
<span style="color:#f92672">[</span><span style="color:#e6db74">&#34;/docker-cli-sample&#34;</span>, <span style="color:#e6db74">&#34;hello&#34;</span>, <span style="color:#e6db74">&#34;world&#34;</span><span style="color:#f92672">]</span>
$ cat docker-cli-sample.log
Args: <span style="color:#f92672">[</span><span style="color:#e6db74">&#34;/docker-cli-sample&#34;</span>, <span style="color:#e6db74">&#34;hello&#34;</span>, <span style="color:#e6db74">&#34;world&#34;</span><span style="color:#f92672">]</span>
</code></pre></div><h2 id="advanced-managing-versions">Advanced: managing versions</h2>
<p>For a bit more comfort we can use a variable for the docker image tag so we can update easier. The <code>.bashrc</code> or <code>.zshrc</code> then looks like:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">export MY_CLI_VERSION<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;1.0&#34;</span>
alias docker-rust-cli<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;docker run --rm -v $(pwd):/cmd-root-dir kevingimbel/rust-docker-cli-sample:$MY_CLI_VERSION&#39;</span>
</code></pre></div><p>And there&rsquo;s that! Everybody else with access to the docker image can now use our CLI by adding the <code>alias</code> and optionally version to their <code>.bashrc</code> or <code>.zshrc</code>.</p>
<h2 id="recap">Recap</h2>
<p>So what did we learn?</p>
<ul>
<li>We can use <a href="https://docs.docker.com/develop/develop-images/multistage-build/#use-multi-stage-builds" title="Docker Documentation about multi-stage builds">multi-stage builds</a> to build our code using docker. This is done by creating a container with <code>FROM image:tag as builder</code></li>
<li>Rust binaries can be run in a small image such as <code>alpine</code> or even in a blank image using <code>FROM scratch</code></li>
<li>We can use an <code>alias</code> to comfortably run the long docker command</li>
<li>By using <code>WORKDIR</code> and volumes we can extract files from the container and save them in the current directory outside the container</li>
</ul>
<p>The source code of the example Rust CLI can be found on <a href="https://github.com/kevingimbel/docker-cli-sample">GitHub at kevingimbel/docker-cli-sample</a>. A working docker image can be found on <a href="https://hub.docker.com/r/kevingimbel/rust-docker-cli-sample">Docker Hub at kevingimbel/rust-docker-cli-sample</a>.</p>
<p>The docker sample can be run with</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">docker run --rm kevingimbel/rust-docker-cli-sample:1.0 hello from docker
</code></pre></div>]]></content><category scheme="https://kevingimbel.de/categories/coding" term="coding" label="coding"/><category scheme="https://kevingimbel.de/tags/rust" term="rust" label="rust"/><category scheme="https://kevingimbel.de/tags/docker" term="docker" label="docker"/><category scheme="https://kevingimbel.de/tags/cli" term="cli" label="cli"/></entry><entry><title type="html">Docker Apache Proxy Setup</title><link href="https://kevingimbel.de/blog/2020/05/docker-apache-proxy-setup/?utm_source=atom_feed" rel="alternate" type="text/html"/><link href="https://kevingimbel.de/blog/2020/01/auto-ssl-with-apache2/?utm_source=atom_feed" rel="related" type="text/html" title="Auto SSL With apache2"/><link href="https://kevingimbel.de/blog/2016/12/gotcha-dockerignore/?utm_source=atom_feed" rel="related" type="text/html" title="Gotcha: dockerignore"/><id>https://kevingimbel.de/blog/2020/05/docker-apache-proxy-setup/</id><published>2020-05-05T00:00:00+00:00</published><updated>2020-05-05T00:00:00+00:00</updated><content type="html"><![CDATA[<p>In this post I&rsquo;d like to detail how I am managing docker containers behind an apache2 proxy on a Ubuntu 18.04. server. I&rsquo;m using one Apache server to route traffic from multiple sub-domains to docker containers all running with docker-compose. This setup is <em>not</em> automated and the containers do not need to interact with each other; It&rsquo;s just how I run software for my private usage.</p>
<h2 id="overview">Overview</h2>
<p>Let&rsquo;s start with an overview image, because this can be quite confusing.</p>

<figure >
  

    <img src="/images/posts/2020/docker-apache-proxy/apache-docker-server-diagram.svg"
      alt="A diagram showing how traffic comes through Apache and is routed to different docker containers exposing services on different TCP ports"
       />
    
  
  <figcaption>
    <p>
      A diagram showing how traffic comes through Apache and is routed to different docker containers exposing services on different TCP ports
      
        
        
    </p> 
  </figcaption>
  
</figure>

<p>The diagram shows how traffic comes from the public internet and hits Apache. This happens for example when you type <a href="https://kevingimbel.de">https://kevingimbel.de</a> into your browser and hit enter. Apache then decides which service running should respond to the request, in most scenarios this will be some PHP code (like WordPress). When we want to use NodeJS or run software from docker we usually do not bind to port 80 (HTTP) or 443 (HTTPS) directly. Instead we need to proxy the request.</p>
<p>In order to make our services accessible without knowing the ports of each container we&rsquo;ll setup a virtual host in Apache.</p>
<p>The goal is:</p>
<ul>
<li>Access each service through a nice domain (like <code>app1.kevingimbel.de</code> instead of <code>kevingimbel.de:8081</code>)</li>
<li>Have SSL for every service</li>
<li>Get new certificates automatically</li>
</ul>
<h2 id="starting-services-with-docker-compose">Starting services with docker-compose</h2>
<p>We&rsquo;ll start with the docker service. As an example I&rsquo;m using one of my projects, <a href="https://github.com/kevingimbel/fakedata_server"><code>fakedata_server</code></a>.</p>
<p>The docker compose file looks like this</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#66d9ef">version</span>: <span style="color:#e6db74">&#34;3&#34;</span>

<span style="color:#66d9ef">services</span>:
    <span style="color:#66d9ef">fakedata_server</span>:
        <span style="color:#66d9ef">image</span>: kevingimbel/fakedata_server:latest
        <span style="color:#66d9ef">ports</span>:
            - <span style="color:#ae81ff">8085</span>:<span style="color:#ae81ff">8000</span>
        <span style="color:#66d9ef">restart</span>: unless-stopped
</code></pre></div><p>We can place this in some directory, I&rsquo;m usually using <code>$HOME/app-name</code>, so for example <code>/home/myuser/fakedata-server/docker-compose.yml</code>. Then we can run <code>docker-compose up -d</code>. The service will now run and restart forever until it is stopped.</p>
<p>If we use <code>curl</code> we can reach the service.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ curl -vL localhost:8085
curl -vL localhost:8085
* Rebuilt URL to: localhost:8085/
*   Trying 127.0.0.1...
* TCP_NODELAY set
* Connected to localhost <span style="color:#f92672">(</span>127.0.0.1<span style="color:#f92672">)</span> port <span style="color:#ae81ff">8085</span> <span style="color:#f92672">(</span><span style="color:#75715e">#0)</span>
&gt; GET / HTTP/1.1
&gt; Host: localhost:8085
&gt; User-Agent: curl/7.58.0
&gt; Accept: */*
&gt;
&lt; HTTP/1.1 <span style="color:#ae81ff">200</span> OK
&lt; Content-Type: text/plain; charset<span style="color:#f92672">=</span>utf-8
&lt; Server: Rocket
&lt; Content-Length: <span style="color:#ae81ff">515</span>
&lt; Date: Tue, <span style="color:#ae81ff">05</span> May <span style="color:#ae81ff">2020</span> 09:35:45 GMT
&lt;

Welcome to the fakedata_generator example implementation as a web server

Available routes:

    /gen/email
    /gen/username
    /gen/domain
    /gen/http_method
    /gen/ipv4
    /gen/enum_r/&lt;input&gt;
    /gen/corpora/&lt;input&gt;


Inputs:

/gen/enum_r/&lt;input&gt;
Specify input as comma-seperated strings, e.g.
/gen/enum_r/hello,world,this,is,a,tes
/gen/enum/horse,cat,dog
/gen/enum/active,inactive,unknown


/gen/corpora/&lt;input&gt;
Specify a corpora dataset, e.g.
/gen/corpora/horse
/gen/corpora/cat
/gen/corpora/fabric

* Connection <span style="color:#75715e">#0 to host localhost left intact</span>
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ curl localhost:8085/gen/email
benefritz@make.org
</code></pre></div><p>The service is working. Yay! Off to the next topic!</p>
<h2 id="proxying-with-apache2">Proxying with apache2</h2>
<p>Now that we have a service running we want to make it accessible with a nice clean URL. We&rsquo;ll use <code>fs.bullgit.science</code> for this purpose, because that&rsquo;s where the service is actually running: <a href="https://fs.bullgit.science/">https://fs.bullgit.science</a>.</p>
<p>First we need to create some apache files:</p>
<ul>
<li>Virtual Host in <code>/etc/apache2/sites-available/fakedata-server.conf</code></li>
<li>Generic Domain config in <code>/etc/apache2/sites-available/domains.conf</code></li>
</ul>
<h3 id="virtual-host">Virtual Host</h3>
<p>The virtual host only contains proxy commands and redirects. We want to redirect all HTTP traffic to HTTPS and all HTTPS traffic should be proxied to the port out service is running on (<code>8085</code> in the example above).</p>
<p>The first part of the config is the redirect. Important here is the <strong>ServerName</strong>! This tells apache for which sub-domain this virtual host should be routed to!</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-xml" data-lang="xml"><span style="color:#f92672">&lt;VirtualHost</span> <span style="color:#960050;background-color:#1e0010">*:80</span><span style="color:#f92672">&gt;</span>
	ServerName fs.bullgit.science
	Redirect permanent / https://fs.bullgit.science/
<span style="color:#f92672">&lt;/VirtualHost&gt;</span>
</code></pre></div><p>The next part is the SSL/HTTPS handler. After the redirect this handler will do the proxying.</p>
<section class="side-by-side align-top">
  

<div class="left ">
    <ul>
<li>
<p><code>ServerName</code> tells apache which virtual host to use (if we have multiple)</p>
</li>
<li>
<p><code>SSLEngine On</code> turns on SSL encryption</p>
</li>
</ul>
<p>This is all that is needed in the virtual host for the auto-ssl feature! The rest of the config will be handled in the <code>domains.conf</code> as described below.</p>
<ul>
<li>
<p><code>ProxyPreserveHost On</code> passes on the <code>Host</code> header from the request (see <a href="https://httpd.apache.org/docs/current/mod/mod_proxy.html#proxypreservehost">documentation</a>)</p>
</li>
<li>
<p><code>ProxyPass / http://127.0.0.1:8085/</code> - this tells apache to sent the traffic to port 8085 on localhost (<code>127.0.0.1</code> is always the IP of the local server)</p>
</li>
<li>
<p><code>ProxyPassReverse / http://127.0.0.1:8085/</code></p>
</li>
</ul>
<p>The last two lines just give some extra logs, it&rsquo;s always good to have them in case something doesn&rsquo;t work or if a tool like <a href="https://fail2ban.org">fail2ban</a> should be used.</p>
<ul>
<li><code>ErrorLog ${APACHE_LOG_DIR}/fs.bullgit.science-error.log</code></li>
<li><code>CustomLog ${APACHE_LOG_DIR}/fs.bullgit.science-access.log combined</code></li>
</ul>
 </div>

<div class="right small">
    <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-xml" data-lang="xml"><span style="color:#f92672">&lt;VirtualHost</span> <span style="color:#960050;background-color:#1e0010">*:443</span><span style="color:#f92672">&gt;</span>
	ServerName fs.bullgit.science

	SSLEngine On

	ProxyPreserveHost On

	ProxyPass / http://127.0.0.1:8085/
	ProxyPassReverse / http://127.0.0.1:8085/

	ErrorLog ${APACHE_LOG_DIR}/fs.bullgit.science-error.log
	CustomLog ${APACHE_LOG_DIR}/fs.bullgit.science-access.log combined
<span style="color:#f92672">&lt;/VirtualHost&gt;</span>
</code></pre></div> </div>


</section>

<p>You can view the full apache2 configuration below.</p>
<details>
    <summary>Click to view file /etc/apache2/sites-available/fakedata-server.conf</summary>
    
    <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-xml" data-lang="xml"><span style="color:#f92672">&lt;VirtualHost</span> <span style="color:#960050;background-color:#1e0010">*:80</span><span style="color:#f92672">&gt;</span>
	ServerName fs.bullgit.science
	Redirect permanent / https://fs.bullgit.science/
<span style="color:#f92672">&lt;/VirtualHost&gt;</span>

<span style="color:#f92672">&lt;VirtualHost</span> <span style="color:#960050;background-color:#1e0010">*:443</span><span style="color:#f92672">&gt;</span>
	ServerName fs.bullgit.science

	SSLEngine On

	ProxyPreserveHost On

	ProxyPass / http://127.0.0.1:8085/
	ProxyPassReverse / http://127.0.0.1:8085/

	ErrorLog ${APACHE_LOG_DIR}/fs.bullgit.science-error.log
	CustomLog ${APACHE_LOG_DIR}/fs.bullgit.science-access.log combined
<span style="color:#f92672">&lt;/VirtualHost&gt;</span>
</code></pre></div> 
</details>
<p>The <code>domains.conf</code> is our SSL config. We will add all sub-domains we want to have covered by our SSL certificate to this configuration. The details on how to enable mod_md for automatic SSL certs with apache2 are written below, the config file looks like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-xml" data-lang="xml">ServerAdmin mailto:yourname@yourserver.com
MDCertificateAgreement accepted
MDomain bullgit.science fs.bullgit.science service-b.bullgit.science

<span style="color:#f92672">&lt;VirtualHost</span> <span style="color:#960050;background-color:#1e0010">_default_:*</span><span style="color:#f92672">&gt;</span>
	DocumentRoot &#34;/var/www/html/&#34;
<span style="color:#f92672">&lt;/VirtualHost&gt;</span>
</code></pre></div><p>The above config will generate a SSL certificate valid for the domains:</p>
<ul>
<li><code>bullgit.science</code></li>
<li><code>fs.bullgit.science</code></li>
<li><code>service-b.bullgit.science</code></li>
</ul>
<p>I&rsquo;ve written about <a href="https://kevingimbel.de/blog/2020/01/auto-ssl-with-apache2/" title="Read more about managing SSL certificates with Apache2">Auto-SSL with Apache2</a> in the past and I&rsquo;m using this feature for my docker containers, too. This way I can have free SSL certificates without the need to manage anything manually.</p>
<p>The Server must run Apache 2.4.30 or newer in order to use the Auto-SSL feature. Instructions on how to upgrade can be found <a href="https://kevingimbel.de/blog/2020/01/auto-ssl-with-apache2/" title="Read more about managing SSL certificates with Apache2">in my article on Apache2 and Auto-SSL</a>.</p>
<p>Once everything is setup we need to enable the configs.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo a2ensite fakedata-server.conf domains.conf
</code></pre></div><p>and then restart the apache2 server.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo systemctl restart apache2
</code></pre></div><section class="note ">
    <span class="note__heading">NOTE</span>
    
    <p>It appears that apache needs to be <em>restarted</em> not just <em>reloaded</em> when a new subdomain is added to the certificate!</p> 
</section>
<p>Now you should be able to access the docker container on a subdomain. For example, <a href="https://fs.bullgit.science/">fs.bullgit.science</a>.</p>
]]></content><category scheme="https://kevingimbel.de/categories/coding" term="coding" label="coding"/><category scheme="https://kevingimbel.de/categories/backend" term="backend" label="backend"/><category scheme="https://kevingimbel.de/tags/server" term="server" label="server"/><category scheme="https://kevingimbel.de/tags/apache2" term="apache2" label="apache2"/><category scheme="https://kevingimbel.de/tags/docker" term="docker" label="docker"/><category scheme="https://kevingimbel.de/tags/proxy" term="proxy" label="proxy"/><category scheme="https://kevingimbel.de/tags/httpd" term="httpd" label="httpd"/></entry><entry><title type="html">Gotcha: dockerignore</title><link href="https://kevingimbel.de/blog/2016/12/gotcha-dockerignore/?utm_source=atom_feed" rel="alternate" type="text/html"/><link href="https://kevingimbel.de/blog/2016/11/farewell-jekyll-hello-hugo/?utm_source=atom_feed" rel="related" type="text/html" title="Farewell Jekyll, Hello Hugo"/><link href="https://kevingimbel.de/blog/2015/12/speed-up-your-jekyll-workflow/?utm_source=atom_feed" rel="related" type="text/html" title="Speed up your Jekyll workflow"/><id>https://kevingimbel.de/blog/2016/12/gotcha-dockerignore/</id><published>2016-12-21T18:02:42+01:00</published><updated>2016-12-21T18:02:42+01:00</updated><content type="html"><![CDATA[<p>Today I was caught off-guard by a docker &ldquo;bug&rdquo; - or so I thought at first. I tried to boot up a project with <code>docker-compose up</code> like I do since <a href="/goodbye-ubuntu-hello-mac">switching to a Mac</a>. Unusual was that <code>docker-compose</code> stopped at the build step and would not finish the boot. After some confusion and after checking the projects <code>docker-compose.yml</code> configuration file I went to GitHub to see the newest <a href="https://github.com/docker/for-mac/issues">docker for mac issues</a> because I was using the beta release and thought a recent update might broke a thing or two. Looking at the issues I found a similar <a href="https://github.com/docker/for-mac/issues/1063">issue in docker/for-mac</a> and commented with my setup and output of <code>docker-compose --verbose up</code> only to realize a good 30 minutes later my setup was the problem all along.</p>
<p>While the configuration files were all correct, I made a mistake and did not provide a <code>.dockerignore</code> file. Without the <code>.dockerignore</code> two 6GB SQL dumps in the same directory which were mounted into the docker container which made the docker daemon crash / hang up. The simple solution was to create the following <code>.dockerignore</code> file.</p>
<pre><code># database directory on the host
.db
# all sql and gz files
*.sql
*.gz
</code></pre><p>Afterwards the <code>docker-compose</code> started without any issues because it now had a build context of around 400MB instead of 13GB.</p>
<p>Lesson learned: Always make sure your <code>.dockerignore</code> is setup right and ignores all big files! The full file looks as follows:</p>
<pre><code>node_modules
.sass-cache
.db
*.sql
*.gz
.git
</code></pre>]]></content><category scheme="https://kevingimbel.de/categories/coding" term="coding" label="coding"/><category scheme="https://kevingimbel.de/categories/devops" term="devops" label="devops"/><category scheme="https://kevingimbel.de/tags/docker" term="docker" label="docker"/><category scheme="https://kevingimbel.de/tags/development" term="development" label="development"/></entry></feed>
<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en_US"><generator uri="https://gohugo.io/" version="0.72.0">Hugo</generator><title type="html">cli on KevOps (%!s(&lt;nil>))</title><link href="https://kevingimbel.de/tags/cli/" rel="alternate" type="text/html" title="HTML"/><link href="https://kevingimbel.de/tags/cli/index.xml" rel="alternate" type="application/rss+xml" title="RSS"/><link href="https://kevingimbel.de/tags/cli/atom.xml" rel="self" type="application/atom+xml" title="Atom"/><link href="https://kevingimbel.de/de/tags/cli/" rel="alternate" type="text/html" hreflang="de" title="[%!s(<nil>)] HTML"/><link href="https://kevingimbel.de/de/tags/cli/index.xml" rel="alternate" type="application/rss+xml" hreflang="de" title="[%!s(<nil>)] RSS"/><link href="https://kevingimbel.de/de/tags/cli/atom.xml" rel="alternate" type="application/atom+xml" hreflang="de" title="[%!s(<nil>)] Atom"/><updated>2020-08-10T10:20:52+02:00</updated><id>https://kevingimbel.de/tags/cli/</id><entry><title type="html">Shipping Rust CLIs with Docker</title><link href="https://kevingimbel.de/blog/2020/08/shipping-rust-clis-with-docker/?utm_source=atom_feed" rel="alternate" type="text/html"/><link href="https://kevingimbel.de/project/license/?utm_source=atom_feed" rel="related" type="text/html" title="License"/><link href="https://kevingimbel.de/blog/2020/05/deno-1.0-released/?utm_source=atom_feed" rel="related" type="text/html" title="Deno 1.0 released"/><link href="https://kevingimbel.de/blog/2020/05/docker-apache-proxy-setup/?utm_source=atom_feed" rel="related" type="text/html" title="Docker Apache Proxy Setup"/><link href="https://kevingimbel.de/blog/2020/04/terrasave/?utm_source=atom_feed" rel="related" type="text/html" title="Terrasave"/><link href="https://kevingimbel.de/blog/2017/01/bash-script-ws/?utm_source=atom_feed" rel="related" type="text/html" title="Bash script: ws"/><id>https://kevingimbel.de/blog/2020/08/shipping-rust-clis-with-docker/</id><published>2020-08-06T00:00:00+00:00</published><updated>2020-08-06T00:00:00+00:00</updated><content type="html"><![CDATA[<p>I recently found a nice and clean way of building and distributing <a href="https://rust-lang.orf">Rust</a> CLI apps using <a href="https://www.docker.com/">docker</a>. For my work I created a Rust app that wraps some AWS SDK functions to make my day-to-day work with AWS easier. This CLI is very focused on the way we work at <a href="https://synoa.de/">Synoa</a> and therefore unfortunately not open source. The tech does not matter much, as we can just create a tiny example &ldquo;app&rdquo; for this blog post.</p>
<h2 id="rust-code">Rust code</h2>
<p>Below is the example Rust code we will use.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">use</span> std::env;

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> args: Vec<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> env::args().collect();
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;{:?}&#34;</span>, args);
}
</code></pre></div><p>This code only prints whatever arguments were passed to the script.</p>
<h2 id="building-the-binary---in-docker">Building the binary - in docker</h2>
<p>Next we will build the binary in docker using a &ldquo;<a href="https://docs.docker.com/develop/develop-images/multistage-build/#use-multi-stage-builds">multi-stage build</a>&rdquo; setup. This way we do not need to manage our local Rust environment, for example we don&rsquo;t need to keep our Rust targets up-to-date or make sure other contributors have the same environment setup - the compiling is all done inside Docker.</p>
<p>We start by declaring a <code>builder</code> container. This container is only used for compiling the binary.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Dockerfile" data-lang="Dockerfile"><span style="color:#66d9ef">FROM</span><span style="color:#e6db74"> clux/muslrust:1.45.0-stable as builder</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">WORKDIR</span><span style="color:#e6db74"> /volume</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">COPY</span> . .<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">RUN</span> cargo build --release<span style="color:#960050;background-color:#1e0010">
</span></code></pre></div><p>These four lines do the following:</p>
<ul>
<li>Create a container based on <a href="https://github.com/clux/muslrust"><code>clux/muslrust</code></a></li>
<li>Give it a name of <code>builder</code> (so we can reference it later)</li>
<li>Declare the working directory to be <code>/volume</code></li>
<li>Copy over all files from the current directory to <code>/volume</code></li>
<li>Run the <code>cargo build --release</code> command which builds our Rust binary</li>
</ul>
<h2 id="creating-the-docker-image">Creating the docker image</h2>
<p>Next, in the same Dockerfile, we declare the actual image. This is where we copy the compiled binary from the &ldquo;builder&rdquo; container.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Dockerfile" data-lang="Dockerfile"><span style="color:#66d9ef">FROM</span><span style="color:#e6db74"> alpine</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#75715e"># Copy the compiled binary from the builder container</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">COPY</span> --from<span style="color:#f92672">=</span>builder /volume/target/x86_64-unknown-linux-musl/release/docker-cli-sample .<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#75715e"># Pass all arguments etc to binary</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">ENTRYPOINT</span> [ <span style="color:#e6db74">&#34;/docker-cli-sample&#34;</span> ]<span style="color:#960050;background-color:#1e0010">
</span></code></pre></div><p>So what happens here?</p>
<ul>
<li>First with <code>FROM alpine</code> we use the slim <a href="https://alpinelinux.org/">Alpine Linux</a> as base image. Depending on what our binary is doing we could also use <code>FROM scratch</code> to not use a base image at all. For my case I chose Alpine because we needed to make HTTPS calls and they didn&rsquo;t work in a &ldquo;scratch&rdquo; image.</li>
<li><code>COPY</code> copies the binary from the builder container and places it in the root directory of our container</li>
<li><code>ENTRYPOINT [ &quot;/docker-cli-sample&quot; ]</code> means we execute the <code>docker-cli-sample</code> binary when we run the container</li>
</ul>
<p>All together, the Dockerfile looks like this.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Dockerfile" data-lang="Dockerfile"><span style="color:#66d9ef">FROM</span><span style="color:#e6db74"> clux/muslrust:1.45.0-stable as builder</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">WORKDIR</span><span style="color:#e6db74"> /volume</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">COPY</span> . .<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">RUN</span> cargo build --release<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">FROM</span><span style="color:#e6db74"> alpine</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">COPY</span> --from<span style="color:#f92672">=</span>builder /volume/target/x86_64-unknown-linux-musl/release/docker-cli-sample .<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">ENTRYPOINT</span> [ <span style="color:#e6db74">&#34;/docker-cli-sample&#34;</span> ]<span style="color:#960050;background-color:#1e0010">
</span></code></pre></div><h2 id="building-the-image-and-running-the-container">Building the image and running the container</h2>
<p>We can build the image now with the <code>docker build</code> command. Open a terminal and type:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">docker build -t kevingimbel/rust-docker-cli-sample:1.0 .  
</code></pre></div><p>Then run the image in a container. <code>--rm</code> makes sure the container is removed after it is executed, as we do not need it anymore.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ docker run --rm kevingimbel/rust-docker-cli-sample:1.0 -hello -world
<span style="color:#f92672">[</span><span style="color:#e6db74">&#34;/docker-cli-sample&#34;</span>, <span style="color:#e6db74">&#34;-hello&#34;</span>, <span style="color:#e6db74">&#34;-world&#34;</span><span style="color:#f92672">]</span>
</code></pre></div><h2 id="setting-up-the-cli-and-docker">Setting up the CLI and docker</h2>
<p>To execute this container like a CLI script we add the following to <code>~/.bashrc</code> (for Bash) or <code>~/.zshrc</code> (for zsh).</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">alias docker-rust-cli<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;docker run --rm kevingimbel/rust-docker-cli-sample:1.0&#39;</span>
</code></pre></div><p>Source the file by running the following, then test the command.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># bash</span>
source ~/.bashrc
<span style="color:#75715e"># zsh</span>
source ~/.zshrc
</code></pre></div><p>Now we can execute the command just like any other CLI. The arguments are all passed to the script, just as if it was a &ldquo;normal&rdquo; binary somewhere in our <code>$PATH</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ docker-rust-cli hello from docker
<span style="color:#f92672">[</span><span style="color:#e6db74">&#34;/docker-cli-sample&#34;</span>, <span style="color:#e6db74">&#34;hello&#34;</span>, <span style="color:#e6db74">&#34;from&#34;</span>, <span style="color:#e6db74">&#34;docker&#34;</span><span style="color:#f92672">]</span>
</code></pre></div><h2 id="advanced-volumes">Advanced: volumes</h2>
<p>We could end this post here, but there&rsquo;s one &ldquo;advanced&rdquo; topic I want to highlight: Volumes. If our script would create or download files we could not access them because they are only inside the container and the container. To prevent this we need to add a volume.</p>
<p>A volume can be added with <code>-v</code> in the docker command.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">alias docker-rust-cli<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;docker run --rm -v $(pwd):/cmd-root-dir kevingimbel/rust-docker-cli-sample:1.0&#39;</span>
</code></pre></div><h3 id="workdir"><code>WORKDIR</code></h3>
<p>Now we need to make sure that our cli app puts created files in the <code>/cmd-root-dir</code> directory. This can be done by specifying the <code>WORKDIR</code> in the Dockerfile. To do this we add a new line above <code>ENTRYPOINT</code> as shown below.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Dockerfile" data-lang="Dockerfile"><span style="color:#66d9ef">FROM</span><span style="color:#e6db74"> clux/muslrust:1.45.0-stable as builder</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">WORKDIR</span><span style="color:#e6db74"> /volume</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">COPY</span> . .<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">RUN</span> cargo build --release<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">FROM</span><span style="color:#e6db74"> alpine</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">COPY</span> --from<span style="color:#f92672">=</span>builder /volume/target/x86_64-unknown-linux-musl/release/docker-cli-sample .<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">WORKDIR</span><span style="color:#e6db74"> /cmd-root-dir</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">ENTRYPOINT</span> [ <span style="color:#e6db74">&#34;/docker-cli-sample&#34;</span> ]<span style="color:#960050;background-color:#1e0010">
</span></code></pre></div><p><code>WORKDIR</code> will create the directory if it doesn&rsquo;t exist. To test the changes, we can adjust the rust script to write to a file.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">use</span> std::env;
<span style="color:#66d9ef">use</span> std::fs;

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() -&gt; <span style="color:#a6e22e">std</span>::io::Result<span style="color:#f92672">&lt;</span>()<span style="color:#f92672">&gt;</span> {
    <span style="color:#66d9ef">let</span> args: Vec<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> env::args().collect();
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;{:?}&#34;</span>, args);
    fs::write(<span style="color:#e6db74">&#34;docker-cli-sample.log&#34;</span>, format<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Args: {:?}&#34;</span>, args))<span style="color:#f92672">?</span>;
    Ok(())
}
</code></pre></div><p>This will write the arguments into the <code>docker-cli-sample.log</code>. Because we set <code>WORKDIR</code> this will execute in the <code>/cmd-root-dir</code> inside the container. To actually get the log, we can now mount the volume with <code>-v</code> in our alias.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">alias docker-rust-cli<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;docker run --rm -v $(pwd):/cmd-root-dir kevingimbel/rust-docker-cli-sample:1.0&#39;</span>
</code></pre></div><p><code>$(pwd)</code> always evaluates to the current directory. This <strong>only works if</strong> we use sigle-quotes (<code>'</code>) in the alias!</p>
<p>So finally, running the command now will yield us the log in the current directory.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ docker-rust-cli
<span style="color:#f92672">[</span><span style="color:#e6db74">&#34;/docker-cli-sample&#34;</span>, <span style="color:#e6db74">&#34;hello&#34;</span>, <span style="color:#e6db74">&#34;world&#34;</span><span style="color:#f92672">]</span>
$ cat docker-cli-sample.log
Args: <span style="color:#f92672">[</span><span style="color:#e6db74">&#34;/docker-cli-sample&#34;</span>, <span style="color:#e6db74">&#34;hello&#34;</span>, <span style="color:#e6db74">&#34;world&#34;</span><span style="color:#f92672">]</span>
</code></pre></div><h2 id="advanced-managing-versions">Advanced: managing versions</h2>
<p>For a bit more comfort we can use a variable for the docker image tag so we can update easier. The <code>.bashrc</code> or <code>.zshrc</code> then looks like:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">export MY_CLI_VERSION<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;1.0&#34;</span>
alias docker-rust-cli<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;docker run --rm -v $(pwd):/cmd-root-dir kevingimbel/rust-docker-cli-sample:$MY_CLI_VERSION&#39;</span>
</code></pre></div><p>And there&rsquo;s that! Everybody else with access to the docker image can now use our CLI by adding the <code>alias</code> and optionally version to their <code>.bashrc</code> or <code>.zshrc</code>.</p>
<h2 id="recap">Recap</h2>
<p>So what did we learn?</p>
<ul>
<li>We can use <a href="https://docs.docker.com/develop/develop-images/multistage-build/#use-multi-stage-builds" title="Docker Documentation about multi-stage builds">multi-stage builds</a> to build our code using docker. This is done by creating a container with <code>FROM image:tag as builder</code></li>
<li>Rust binaries can be run in a small image such as <code>alpine</code> or even in a blank image using <code>FROM scratch</code></li>
<li>We can use an <code>alias</code> to comfortably run the long docker command</li>
<li>By using <code>WORKDIR</code> and volumes we can extract files from the container and save them in the current directory outside the container</li>
</ul>
<p>The source code of the example Rust CLI can be found on <a href="https://github.com/kevingimbel/docker-cli-sample">GitHub at kevingimbel/docker-cli-sample</a>. A working docker image can be found on <a href="https://hub.docker.com/r/kevingimbel/rust-docker-cli-sample">Docker Hub at kevingimbel/rust-docker-cli-sample</a>.</p>
<p>The docker sample can be run with</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">docker run --rm kevingimbel/rust-docker-cli-sample:1.0 hello from docker
</code></pre></div>]]></content><category scheme="https://kevingimbel.de/categories/coding" term="coding" label="coding"/><category scheme="https://kevingimbel.de/tags/rust" term="rust" label="rust"/><category scheme="https://kevingimbel.de/tags/docker" term="docker" label="docker"/><category scheme="https://kevingimbel.de/tags/cli" term="cli" label="cli"/></entry><entry><title type="html">Terrasave</title><link href="https://kevingimbel.de/blog/2020/04/terrasave/?utm_source=atom_feed" rel="alternate" type="text/html"/><link href="https://kevingimbel.de/blog/2017/01/bash-script-ws/?utm_source=atom_feed" rel="related" type="text/html" title="Bash script: ws"/><link href="https://kevingimbel.de/blog/2018/04/til-bash-select/?utm_source=atom_feed" rel="related" type="text/html" title="TIL: Bash select"/><link href="https://kevingimbel.de/blog/2017/01/deploy-a-static-site-with-git/?utm_source=atom_feed" rel="related" type="text/html" title="Deploy a static site with git"/><link href="https://kevingimbel.de/blog/2017/01/writing-nodejs-cli-tools/?utm_source=atom_feed" rel="related" type="text/html" title="Writing NodeJS cli tools"/><id>https://kevingimbel.de/blog/2020/04/terrasave/</id><published>2020-04-24T00:00:00+00:00</published><updated>2020-04-24T00:00:00+00:00</updated><content type="html"><![CDATA[<p>I just released a tiny tool function I&rsquo;ve been using for some time called <a href="https://github.com/kevingimbel/terrasave" title="View terrasave source code on GitHub">terrasave</a>. It&rsquo;s a Bash / Fish function that prevents you from running <code>terraform</code> without the <code>-target</code> option.</p>
<h2 id="why-does-this-exist">Why does this exist?</h2>
<p>In terraform it is incredibly easy to destroy things with <code>terraform apply</code>. If you run apply terraform shows a huge output and sometimes you may overlook a thing being &ldquo;replaced&rdquo; instead of updated. Once upon a time I destroyed a MongoDB Atlas Cluster this way and lost all its data, because the &ldquo;must be replaced&rdquo; was hidden in a lot of terraform output and I simply didn&rsquo;t see it. I only realized when terraform logged &ldquo;Still destroying cluster&hellip;&rdquo; to the console.</p>
<p>Some terraform resources, like Amazon ECS Services, are not idempotent, so they change on every apply. This cluttered my terminal with stuff I could ignore on every change as well as unnecessary updates to the infra (ECS Services being replaced despite no changes were made).</p>
<p>To prevent this, I forced myself to only use terraform with the -target switch, and this tiny script helps me accomplish that.</p>
<h2 id="usage">Usage</h2>
<p>After <a href="https://github.com/kevingimbel/terrasave#installation" title="View installation instructions on GitHub.com">installing the tool</a> you can just work as you&rsquo;d normally do: <code>terrasave</code> acts as a shell alias for <code>terraform</code> so whenever you run <code>terraform</code> in a terminal, the call goes &ldquo;through&rdquo; the <code>terrasave</code> function. If the function detects <code>apply</code> but not <code>-target</code> it outputs an error and exits.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ terraform apply
Please run <span style="color:#e6db74">&#34;terraform apply&#34;</span> with -target option
</code></pre></div><p>If you <strong>must</strong> run terraform without a target you can do so by specifying an environment variable:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ TERRAFORM_SAVE_DISABLE_I_KNOW_WHAT_I_DO<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span> terraform apply
</code></pre></div><p>You can get the source code and installation instructions on <a href="https://github.com/kevingimbel/terrasave">github.com/kevingimbel/terrasave</a>. Hopefully this little tool will save your infra. :)</p>
]]></content><category scheme="https://kevingimbel.de/categories/coding" term="coding" label="coding"/><category scheme="https://kevingimbel.de/categories/tools" term="tools" label="tools"/><category scheme="https://kevingimbel.de/tags/devops" term="devops" label="devops"/><category scheme="https://kevingimbel.de/tags/terraform" term="terraform" label="terraform"/><category scheme="https://kevingimbel.de/tags/cli" term="cli" label="cli"/><category scheme="https://kevingimbel.de/tags/bash" term="bash" label="bash"/><category scheme="https://kevingimbel.de/tags/fish" term="fish" label="fish"/></entry><entry><title type="html">Bash script: ws</title><link href="https://kevingimbel.de/blog/2017/01/bash-script-ws/?utm_source=atom_feed" rel="alternate" type="text/html"/><link href="https://kevingimbel.de/blog/2015/01/snippet-sass-source-maps-with-gulp/?utm_source=atom_feed" rel="related" type="text/html" title="Snippet: SASS Source Maps with Gulp"/><link href="https://kevingimbel.de/blog/2014/01/labels-in-gmail/?utm_source=atom_feed" rel="related" type="text/html" title="Labels in GMail"/><link href="https://kevingimbel.de/blog/2017/01/writing-nodejs-cli-tools/?utm_source=atom_feed" rel="related" type="text/html" title="Writing NodeJS cli tools"/><link href="https://kevingimbel.de/blog/2014/06/useful-web-developer-tools/?utm_source=atom_feed" rel="related" type="text/html" title="Useful Web Developer Tools"/><id>https://kevingimbel.de/blog/2017/01/bash-script-ws/</id><published>2017-01-12T19:22:48+01:00</published><updated>2017-01-12T19:22:48+01:00</updated><content type="html"><![CDATA[<p>For the past year or so I had a little function in my <code>.bash_profile</code> file which made my interaction with the terminal roughly 9001% better - yeah, over 9000! This little function is called <code>ws</code> and makes switching between projects inside my workspace a lot easier. Both my private and work projects are inside the <code>~/Development</code> directory. If I want to get to a project I would normally navigate like <code>cd ~/Development/private/github/kevingimbel/kevingimbel.com</code> - even with tab completion I am too lazy to type this every time I want to work on my website, so I wrote a script for it!</p>
<h3 id="the-script-ws">The script: <code>ws</code></h3>
<p>The script is actually a shell function and it looks like this.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh"><span style="color:#66d9ef">function</span> ws<span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
  local workspace<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;</span>$HOME<span style="color:#e6db74">/Development&#34;</span>
	<span style="color:#75715e"># $1 is the target directory</span>
  local target_dir<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;</span>$1<span style="color:#e6db74">&#34;</span>
  <span style="color:#75715e"># We start searching from the workspace dir</span>
  cd $workspace
  <span style="color:#75715e"># -maxdepth is the max directories to go &#34;down&#34;</span>
  <span style="color:#75715e"># head -n1 gives back the first result</span>
  workspace_path<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>find . -maxdepth <span style="color:#ae81ff">3</span> -type d -name <span style="color:#e6db74">&#34;*</span>$target_dir<span style="color:#e6db74">*&#34;</span> | head -n1<span style="color:#66d9ef">)</span>
  <span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span>  -z <span style="color:#e6db74">&#34;</span>$workspace_path<span style="color:#e6db74">&#34;</span> <span style="color:#f92672">]</span>; <span style="color:#66d9ef">then</span>
    echo <span style="color:#e6db74">&#34;Directory &#39;</span>$target_dir<span style="color:#e6db74">&#39; not found. Changing to </span>$workspace<span style="color:#e6db74">&#34;</span>
  <span style="color:#66d9ef">else</span>
    cd <span style="color:#e6db74">&#34;</span>$workspace_path<span style="color:#e6db74">&#34;</span>
  <span style="color:#66d9ef">fi</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>This function is placed <a href="https://github.com/kevingimbel/dotfiles/blob/997590a65c134326ca051e1e28a78f947673831d/.zshrc#L14-L28">inside my ~/.bash_profile</a> or <code>~/.zshrc</code> so the function is available on every terminal start. It might look odd if your not too farmiliar with shell scripts but it is really rather simple and basic - let&rsquo;s explore it line by line.</p>
<p>With <code>function ws()</code> we declare the function name. In shell scripts a function name has parentheses after it tho it does not take arguments this way (If you know why this is, <a href="https://github.com/kevingimbel/kevingimbel.com/issues">open an issue and explain it please</a> or <a href="https://twitter.com/_kevinatari">tweet me</a>!). The next lines declare a local variable, <code>workspace</code> and then <code>target_dir=$1</code> were I assign whatever is passed to the function as being the target directory the user is trying to find. Then, I execute <code>cd $workspace</code> to go to the workspace directory and start a search with <code>workspace_path=$(find -maxdepth 3 -type d -name &quot;*$target_dir*&quot; | head -n1)</code> - now that might look weird. What happens here is the following:</p>
<ul>
<li>We declare a variable, <code>workspace_path</code></li>
<li>We execute a function with <code>$()</code></li>
<li>We use <code>find . -maxdepth 3 -type d -name &quot;*$target_dor*&quot;</code> to search for a <code>d</code>irectory with a name similar to <code>$target_dir</code> (the variable from earlier)</li>
<li>We then pipe (<code>|</code>) the output from find to <code>head</code> and read in the first line <code>-n1</code> - this is the first match</li>
<li>The return value from <code>$(find ... |Â head -n1)</code> is then available in the <code>$workspace_path</code> variable</li>
</ul>
<p><code>$workspace_path</code> now holds whatever directory was found - or nothing. This is why we check if it is empty (<code>-z &quot;$workspace_path&quot;</code>) in the <code>if</code> block.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh"><span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span>  -z <span style="color:#e6db74">&#34;</span>$workspace_path<span style="color:#e6db74">&#34;</span> <span style="color:#f92672">]</span>; <span style="color:#66d9ef">then</span>
  echo <span style="color:#e6db74">&#34;Directory &#39;</span>$target_dir<span style="color:#e6db74">&#39; not found. Changing to </span>$workspace<span style="color:#e6db74">&#34;</span>
<span style="color:#66d9ef">else</span>
  cd <span style="color:#e6db74">&#34;</span>$workspace_path<span style="color:#e6db74">&#34;</span>
<span style="color:#66d9ef">fi</span>
</code></pre></div><p>This reads: If <code>$workspace_path</code> is empty, then <code>echo</code> the directory was not found and notify the user we changed to <code>$workspace</code> with the <code>cd $workspace</code> earlier. Else, <code>cd</code> into the found directory. And that&rsquo;s it! Some examples can be seen in the screenshot below.</p>

<figure >
  

    <img src="/images/posts/2017/bash-ws/bash-ws-function-in-use.png"
      alt="Using the ws function to navigate through my workspace"
       />
    
  
  <figcaption>
    <p>
      Using the ws function to navigate through my workspace
      
        
        
    </p> 
  </figcaption>
  
</figure>

<p>I am sure the <code>ws</code> function can be improved more but it has served my needs well so far. One optimisation might be to use the second argument, <code>$2</code>, as parameter for <code>-maxdepth</code>.</p>
]]></content><category scheme="https://kevingimbel.de/categories/coding" term="coding" label="coding"/><category scheme="https://kevingimbel.de/categories/tools" term="tools" label="tools"/><category scheme="https://kevingimbel.de/categories/devops" term="devops" label="devops"/><category scheme="https://kevingimbel.de/tags/cli" term="cli" label="cli"/><category scheme="https://kevingimbel.de/tags/bash" term="bash" label="bash"/><category scheme="https://kevingimbel.de/tags/scripting" term="scripting" label="scripting"/><category scheme="https://kevingimbel.de/tags/automation" term="automation" label="automation"/><category scheme="https://kevingimbel.de/tags/workflow" term="workflow" label="workflow"/><category scheme="https://kevingimbel.de/tags/productivity" term="productivity" label="productivity"/></entry><entry><title type="html">Writing NodeJS cli tools</title><link href="https://kevingimbel.de/blog/2017/01/writing-nodejs-cli-tools/?utm_source=atom_feed" rel="alternate" type="text/html"/><link href="https://kevingimbel.de/blog/2015/03/getting-into-performance-measurement/?utm_source=atom_feed" rel="related" type="text/html" title="Getting into Performance Measurement"/><link href="https://kevingimbel.de/blog/2014/08/endless-multi-dimensional-navigation/?utm_source=atom_feed" rel="related" type="text/html" title="Endless Multi-Dimensional Navigation"/><link href="https://kevingimbel.de/blog/2014/07/a-closer-look-to-closure/?utm_source=atom_feed" rel="related" type="text/html" title="A closer look to closure"/><link href="https://kevingimbel.de/blog/2014/05/passing-arguments-in-javascript/?utm_source=atom_feed" rel="related" type="text/html" title="Passing Arguments in JavaScript"/><link href="https://kevingimbel.de/blog/2014/02/pure-javascript-slider/?utm_source=atom_feed" rel="related" type="text/html" title="Pure JavaScript slider"/><id>https://kevingimbel.de/blog/2017/01/writing-nodejs-cli-tools/</id><published>2017-01-09T18:02:48+01:00</published><updated>2017-01-09T18:02:48+01:00</updated><content type="html"><![CDATA[<p>Over 2015 and 2016 I got more and more interested in automating my daily workflows with scripts. For this purpose I learned Bash Scripting (or Shell Scripting) and started writing my first scripts to automate repeating tasks, <a href="https://github.com/kevingimbel/vhost">creating apache vhosts</a> files for example. Recently I started exploring how to implement command line tools in NodeJS and this post should give an overview.</p>
<h3 id="shebang">Shebang</h3>
<blockquote>
<p>If you already know what a Shebang is skip to <a href="/writing-nodejs-cli-tools/#writing-a-tiny-node-cli-script">the next section</a></p>
</blockquote>
<p>Shell Scripts always start with a <a href="https://en.wikipedia.org/wiki/Shebang_(Unix)">Shebang</a> on the first line. This line is used to indicate which program is used to execute the following script. For Bash scripts the Shebang is <code>#!/bin/bash</code>. What the OS or program loader does when executing the script is the following. Consider this sample script named <code>hello.sh</code></p>
<pre><code>#!/bin/bash
echo &quot;Hello World!&quot;
</code></pre><p>When it is executed from the command line (cli) with <code>./hello.sh</code> the operating system executes the script (<code>echo &quot;Hello World!&quot;</code>) with <code>/bin/bash</code>. Equally, you could run <code>/bin/bash ./hello.sh</code>. When programming a bash script you can also set it to exit on every error, either with <code>set -e</code> or with a shebang similar to <code>#!/bin/bash -e</code>. The screenshot below demonstrates the difference when running a invalid shell script <code>bad.sh</code>.</p>

<figure >
  

    <img src="/images/posts/2017/node-cli/shell-shebang-example.png"
      alt="Executing a invalid bash script without shebang and with shebang and -e flag"
       />
    
  
  <figcaption>
    <p>
      Executing a invalid bash script without shebang and with shebang and -e flag
      
        
        
    </p> 
  </figcaption>
  
</figure>

<p>As you can see without the <code>#!/bin/bash -e</code> shebang the script will execute even after an error occurred - this might not be intended behavior. Anyway, the topic of this post is node and the Shebang in node is essential. NodeJS Scripts are JavaScript and cannot be run - like shell scripts - without an Shebang to tell the system to invoke them with node. The NodeJS Shebang looks a bit different and specifies the &ldquo;environment&rdquo; or <code>env</code> with <code>/usr/bin/env</code>. The Shebang then reads <code>#!/usr/bin/env node</code>. Without the Shebang NodeJS scripts will fail immediately after being invoked as seen in the following screenshot.</p>

<figure >
  

    <img src="/images/posts/2017/node-cli/node-without-and-with-shebang.png"
      alt="Node Script executed with and without shebang"
       />
    
  
  <figcaption>
    <p>
      Node Script executed with and without shebang
      
        
        
    </p> 
  </figcaption>
  
</figure>

<p>While it is not necessarily needed for scripts written in in Shell/Bash the Shebang cannot be omitted from NodeJS scripts intended to be run as command line program.</p>
<p>Well, that has been a fun excursion into the world of shell scripting. Back to node!</p>
<h3 id="writing-a-tiny-node-cli-script">Writing a tiny node cli script</h3>
<p>Since we now know how to use a Shebang and how to invoke out Node scripts from the command line we may write a script. Let&rsquo;s keep it simple. We will greet the person executing the script.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#75715e">#!/usr/bin/env node
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">sayHello</span> <span style="color:#f92672">=</span> () =&gt; {
  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`Hello, </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">process</span>.<span style="color:#a6e22e">env</span>.<span style="color:#a6e22e">USER</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>)
}

<span style="color:#a6e22e">sayHello</span>()
</code></pre></div><p>Let&rsquo;s save the script and run it with <code>$ node hello.js</code> from the command line.</p>

<figure >
  

    <img src="/images/posts/2017/node-cli/node-running-hello-js.png"
      alt="Running the hello.js script"
       />
    
  
  <figcaption>
    <p>
      Running the hello.js script
      
        
        
    </p> 
  </figcaption>
  
</figure>

<p>Now that&rsquo;s interesting: The script greets the currently logged-in user! That&rsquo;s the case because we make use of the <code>process</code> variable which holds information about the current environment - the <code>env</code> object for example holds your environment variables. Add a new function to <code>hello.js</code> to see the output.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript">
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">printEnv</span> <span style="color:#f92672">=</span> () =&gt; {
  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">process</span>.<span style="color:#a6e22e">env</span>)
}

<span style="color:#a6e22e">printEnv</span>()
</code></pre></div><p>You will see the <code>USER</code> variable is part of the environment object and holds the name of the logged-in user. This way node scripts can access terminal variables and use them. Run <code>export _test=123</code> and then <code>node hello.js</code> - <code>_test</code> is now part of the environment. By using the Environment we can make a script execute different tasks depending on the environment, as seen in the next snippet.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">log</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">message</span>, <span style="color:#a6e22e">level</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>) =&gt; {
  <span style="color:#66d9ef">if</span>(<span style="color:#a6e22e">process</span>.<span style="color:#a6e22e">env</span>.<span style="color:#a6e22e">NODE_ENV</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;production&#39;</span>) {
    <span style="color:#a6e22e">writeLogFile</span>(<span style="color:#a6e22e">message</span>, <span style="color:#a6e22e">level</span>)
  } <span style="color:#66d9ef">else</span> {
    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">message</span>)
  }
}

<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">writeLogFile</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">message</span>, <span style="color:#a6e22e">level</span>) =&gt; {
  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">error</span>(<span style="color:#e6db74">&#39;Not implemented&#39;</span>)
  <span style="color:#a6e22e">process</span>.<span style="color:#a6e22e">exit</span>(<span style="color:#ae81ff">1</span>)
}

<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;This is a test!&#34;</span>)
</code></pre></div><p>Here we have a log function which either runs the <code>writeLogFile</code> function when in production mode or logs to the console if we are in any other mode (development for example.)</p>

<figure >
  

    <img src="/images/posts/2017/node-cli/node-using-process-environment.png"
      alt="Making use of the environment in a node cli script"
       />
    
  
  <figcaption>
    <p>
      Making use of the environment in a node cli script
      
        
        
    </p> 
  </figcaption>
  
</figure>

<p>As you can see in the screenshot depending on the <code>NODE_ENV</code> variable a different function is executed. The environment can be set inline (<code>$ export NODE_ENV=production</code>) for the duration of the shell session or it can be set permanent, e.g. by adding it to the shell runtime file (<code>~/.zshrc</code> or <code>~/.bashrc</code>). You may also noticed the <code>process.exit(1)</code> inside the <code>writeLogFile</code> function. The <code>exit</code> function enables us to use exit codes to indicate if our script ended successful or not to other processes. If a script exits with <code>0</code> it was successful, everything else is considered an error. To see how a script exits you can run <code>echo $?</code> inside a terminal.</p>
<p>You can read more about exit codes in <a href="http://www.tldp.org/LDP/abs/html/exit-status.html">the resources of TLDP</a>.</p>
<p>So far we learned that Node CLI scripts:</p>
<ul>
<li>need a shebang, <code>#!/usr/bin/env node</code></li>
<li>are written in regular JavaScript</li>
<li>can access the environment</li>
<li>can exit using <code>process.exit(exit_code)</code></li>
<li>can utilize lots of Node packages</li>
</ul>
<p>And that&rsquo;s it for today. All the example scripts are <a href="https://github.com/kevingimbel/blog-node-cli-tools-data">available on GitHub</a>.</p>
]]></content><category scheme="https://kevingimbel.de/categories/coding" term="coding" label="coding"/><category scheme="https://kevingimbel.de/categories/nodejs" term="nodejs" label="nodejs"/><category scheme="https://kevingimbel.de/categories/tools" term="tools" label="tools"/><category scheme="https://kevingimbel.de/tags/nodejs" term="nodejs" label="nodejs"/><category scheme="https://kevingimbel.de/tags/javascript" term="javascript" label="javascript"/><category scheme="https://kevingimbel.de/tags/cli" term="cli" label="cli"/></entry></feed>
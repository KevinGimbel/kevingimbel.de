<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en_US"><generator uri="https://gohugo.io/" version="0.72.0">Hugo</generator><title type="html">nodejs on KevOps</title><link href="https://kevingimbel.de/categories/nodejs/" rel="alternate" type="text/html" title="HTML"/><link href="https://kevingimbel.de/categories/nodejs/index.xml" rel="alternate" type="application/rss+xml" title="RSS"/><link href="https://kevingimbel.de/categories/nodejs/atom.xml" rel="self" type="application/atom+xml" title="Atom"/><updated>2020-08-06T14:34:53+02:00</updated><id>https://kevingimbel.de/categories/nodejs/</id><entry><title type="html">Writing NodeJS cli tools</title><link href="https://kevingimbel.de/blog/2017/01/writing-nodejs-cli-tools/?utm_source=atom_feed" rel="alternate" type="text/html"/><link href="https://kevingimbel.de/blog/2015/03/getting-into-performance-measurement/?utm_source=atom_feed" rel="related" type="text/html" title="Getting into Performance Measurement"/><link href="https://kevingimbel.de/blog/2014/08/endless-multi-dimensional-navigation/?utm_source=atom_feed" rel="related" type="text/html" title="Endless Multi-Dimensional Navigation"/><link href="https://kevingimbel.de/blog/2014/07/a-closer-look-to-closure/?utm_source=atom_feed" rel="related" type="text/html" title="A closer look to closure"/><link href="https://kevingimbel.de/blog/2014/05/passing-arguments-in-javascript/?utm_source=atom_feed" rel="related" type="text/html" title="Passing Arguments in JavaScript"/><link href="https://kevingimbel.de/blog/2014/02/pure-javascript-slider/?utm_source=atom_feed" rel="related" type="text/html" title="Pure JavaScript slider"/><id>https://kevingimbel.de/blog/2017/01/writing-nodejs-cli-tools/</id><published>2017-01-09T18:02:48+01:00</published><updated>2017-01-09T18:02:48+01:00</updated><content type="html"><![CDATA[<p>Over 2015 and 2016 I got more and more interested in automating my daily workflows with scripts. For this purpose I learned Bash Scripting (or Shell Scripting) and started writing my first scripts to automate repeating tasks, <a href="https://github.com/kevingimbel/vhost">creating apache vhosts</a> files for example. Recently I started exploring how to implement command line tools in NodeJS and this post should give an overview.</p>
<h3 id="shebang">Shebang</h3>
<blockquote>
<p>If you already know what a Shebang is skip to <a href="/writing-nodejs-cli-tools/#writing-a-tiny-node-cli-script">the next section</a></p>
</blockquote>
<p>Shell Scripts always start with a <a href="https://en.wikipedia.org/wiki/Shebang_(Unix)">Shebang</a> on the first line. This line is used to indicate which program is used to execute the following script. For Bash scripts the Shebang is <code>#!/bin/bash</code>. What the OS or program loader does when executing the script is the following. Consider this sample script named <code>hello.sh</code></p>
<pre><code>#!/bin/bash
echo &quot;Hello World!&quot;
</code></pre><p>When it is executed from the command line (cli) with <code>./hello.sh</code> the operating system executes the script (<code>echo &quot;Hello World!&quot;</code>) with <code>/bin/bash</code>. Equally, you could run <code>/bin/bash ./hello.sh</code>. When programming a bash script you can also set it to exit on every error, either with <code>set -e</code> or with a shebang similar to <code>#!/bin/bash -e</code>. The screenshot below demonstrates the difference when running a invalid shell script <code>bad.sh</code>.</p>

<figure >
  

    <img src="/images/posts/2017/node-cli/shell-shebang-example.png"
      alt="Executing a invalid bash script without shebang and with shebang and -e flag"
       />
    
  
  <figcaption>
    <p>
      Executing a invalid bash script without shebang and with shebang and -e flag
      
        
        
    </p> 
  </figcaption>
  
</figure>

<p>As you can see without the <code>#!/bin/bash -e</code> shebang the script will execute even after an error occurred - this might not be intended behavior. Anyway, the topic of this post is node and the Shebang in node is essential. NodeJS Scripts are JavaScript and cannot be run - like shell scripts - without an Shebang to tell the system to invoke them with node. The NodeJS Shebang looks a bit different and specifies the &ldquo;environment&rdquo; or <code>env</code> with <code>/usr/bin/env</code>. The Shebang then reads <code>#!/usr/bin/env node</code>. Without the Shebang NodeJS scripts will fail immediately after being invoked as seen in the following screenshot.</p>

<figure >
  

    <img src="/images/posts/2017/node-cli/node-without-and-with-shebang.png"
      alt="Node Script executed with and without shebang"
       />
    
  
  <figcaption>
    <p>
      Node Script executed with and without shebang
      
        
        
    </p> 
  </figcaption>
  
</figure>

<p>While it is not necessarily needed for scripts written in in Shell/Bash the Shebang cannot be omitted from NodeJS scripts intended to be run as command line program.</p>
<p>Well, that has been a fun excursion into the world of shell scripting. Back to node!</p>
<h3 id="writing-a-tiny-node-cli-script">Writing a tiny node cli script</h3>
<p>Since we now know how to use a Shebang and how to invoke out Node scripts from the command line we may write a script. Let&rsquo;s keep it simple. We will greet the person executing the script.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#75715e">#!/usr/bin/env node
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">sayHello</span> <span style="color:#f92672">=</span> () =&gt; {
  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`Hello, </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">process</span>.<span style="color:#a6e22e">env</span>.<span style="color:#a6e22e">USER</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>)
}

<span style="color:#a6e22e">sayHello</span>()
</code></pre></div><p>Let&rsquo;s save the script and run it with <code>$ node hello.js</code> from the command line.</p>

<figure >
  

    <img src="/images/posts/2017/node-cli/node-running-hello-js.png"
      alt="Running the hello.js script"
       />
    
  
  <figcaption>
    <p>
      Running the hello.js script
      
        
        
    </p> 
  </figcaption>
  
</figure>

<p>Now that&rsquo;s interesting: The script greets the currently logged-in user! That&rsquo;s the case because we make use of the <code>process</code> variable which holds information about the current environment - the <code>env</code> object for example holds your environment variables. Add a new function to <code>hello.js</code> to see the output.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript">
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">printEnv</span> <span style="color:#f92672">=</span> () =&gt; {
  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">process</span>.<span style="color:#a6e22e">env</span>)
}

<span style="color:#a6e22e">printEnv</span>()
</code></pre></div><p>You will see the <code>USER</code> variable is part of the environment object and holds the name of the logged-in user. This way node scripts can access terminal variables and use them. Run <code>export _test=123</code> and then <code>node hello.js</code> - <code>_test</code> is now part of the environment. By using the Environment we can make a script execute different tasks depending on the environment, as seen in the next snippet.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">log</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">message</span>, <span style="color:#a6e22e">level</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>) =&gt; {
  <span style="color:#66d9ef">if</span>(<span style="color:#a6e22e">process</span>.<span style="color:#a6e22e">env</span>.<span style="color:#a6e22e">NODE_ENV</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;production&#39;</span>) {
    <span style="color:#a6e22e">writeLogFile</span>(<span style="color:#a6e22e">message</span>, <span style="color:#a6e22e">level</span>)
  } <span style="color:#66d9ef">else</span> {
    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">message</span>)
  }
}

<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">writeLogFile</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">message</span>, <span style="color:#a6e22e">level</span>) =&gt; {
  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">error</span>(<span style="color:#e6db74">&#39;Not implemented&#39;</span>)
  <span style="color:#a6e22e">process</span>.<span style="color:#a6e22e">exit</span>(<span style="color:#ae81ff">1</span>)
}

<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;This is a test!&#34;</span>)
</code></pre></div><p>Here we have a log function which either runs the <code>writeLogFile</code> function when in production mode or logs to the console if we are in any other mode (development for example.)</p>

<figure >
  

    <img src="/images/posts/2017/node-cli/node-using-process-environment.png"
      alt="Making use of the environment in a node cli script"
       />
    
  
  <figcaption>
    <p>
      Making use of the environment in a node cli script
      
        
        
    </p> 
  </figcaption>
  
</figure>

<p>As you can see in the screenshot depending on the <code>NODE_ENV</code> variable a different function is executed. The environment can be set inline (<code>$ export NODE_ENV=production</code>) for the duration of the shell session or it can be set permanent, e.g. by adding it to the shell runtime file (<code>~/.zshrc</code> or <code>~/.bashrc</code>). You may also noticed the <code>process.exit(1)</code> inside the <code>writeLogFile</code> function. The <code>exit</code> function enables us to use exit codes to indicate if our script ended successful or not to other processes. If a script exits with <code>0</code> it was successful, everything else is considered an error. To see how a script exits you can run <code>echo $?</code> inside a terminal.</p>
<p>You can read more about exit codes in <a href="http://www.tldp.org/LDP/abs/html/exit-status.html">the resources of TLDP</a>.</p>
<p>So far we learned that Node CLI scripts:</p>
<ul>
<li>need a shebang, <code>#!/usr/bin/env node</code></li>
<li>are written in regular JavaScript</li>
<li>can access the environment</li>
<li>can exit using <code>process.exit(exit_code)</code></li>
<li>can utilize lots of Node packages</li>
</ul>
<p>And that&rsquo;s it for today. All the example scripts are <a href="https://github.com/kevingimbel/blog-node-cli-tools-data">available on GitHub</a>.</p>
]]></content><category scheme="https://kevingimbel.de/categories/coding" term="coding" label="coding"/><category scheme="https://kevingimbel.de/categories/nodejs" term="nodejs" label="nodejs"/><category scheme="https://kevingimbel.de/categories/tools" term="tools" label="tools"/><category scheme="https://kevingimbel.de/tags/nodejs" term="nodejs" label="nodejs"/><category scheme="https://kevingimbel.de/tags/javascript" term="javascript" label="javascript"/><category scheme="https://kevingimbel.de/tags/cli" term="cli" label="cli"/></entry><entry><title type="html">Snippet: SASS Source Maps with Gulp</title><link href="https://kevingimbel.de/blog/2015/01/snippet-sass-source-maps-with-gulp/?utm_source=atom_feed" rel="alternate" type="text/html"/><link href="https://kevingimbel.de/blog/2014/01/labels-in-gmail/?utm_source=atom_feed" rel="related" type="text/html" title="Labels in GMail"/><link href="https://kevingimbel.de/blog/2014/06/useful-web-developer-tools/?utm_source=atom_feed" rel="related" type="text/html" title="Useful Web Developer Tools"/><link href="https://kevingimbel.de/blog/2013/10/from-0-to-sass/?utm_source=atom_feed" rel="related" type="text/html" title="From 0 To Sass"/><id>https://kevingimbel.de/blog/2015/01/snippet-sass-source-maps-with-gulp/</id><published>2015-01-22T00:00:00+00:00</published><updated>2015-01-22T00:00:00+00:00</updated><content type="html"><![CDATA[<p>Yesterday I finally took a few moments to implement Source Maps with Gulp for one of our client projects at work. I
wanted to use the benefits of Source Maps for quite some time but never actually found the time to wrap my head around
it (aka throw in another Gulp plugin). Source Maps are used to connect your pre-compiled files, like Sass, with the
later compiled CSS - so inside the Dev Tools you can see for every line of CSS from which Sass file it comes - this is
super handy once your project get&rsquo;s bigger! Anyway, here&rsquo;s how to implement them with <a href="http://gulpjs.com0">Gulp</a>,
<a href="https://www.npmjs.com/package/gulp-sass">Gulp-Sass</a> and <a href="https://www.npmjs.com/package/gulp-autoprefixer">Autoprefixer</a>.</p>
<p>First of all, you need to install  the different gulp plugins (and gulp, if you haven&rsquo;t).</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ npm install --save-dev gulp-sass gulp-sourcemaps gulp-autoprefixer
</code></pre></div><p>After everything is installed we&rsquo;ll create the basic Gulp setup.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js">  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">gulp</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">require</span>(<span style="color:#e6db74">&#39;gulp&#39;</span>),
      <span style="color:#a6e22e">sass</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">require</span>(<span style="color:#e6db74">&#39;gulp-sass&#39;</span>),
      <span style="color:#a6e22e">prefix</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">require</span>(<span style="color:#e6db74">&#39;gulp-autoprefixer&#39;</span>),
      <span style="color:#a6e22e">maps</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">require</span>(<span style="color:#e6db74">&#39;gulp-sourcemaps&#39;</span>);

  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">path</span> <span style="color:#f92672">=</span> {
        <span style="color:#a6e22e">scss</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;./skin/frontend/my-theme/default/scss/&#39;</span>,
        <span style="color:#a6e22e">css</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;./skin/frontend/my-theme/default/css/&#39;</span>
      }
</code></pre></div><p>Next the tasks will be created, I split them into 2, one for Sass and Source Maps and one for
Autoprefixer. It&rsquo;s important to create the Source Maps <em>before</em> using Autoprefixer, otherwise the line numbers won&rsquo;t be
right. This happen because Autoprefixer adds more properties to your compiled CSS!</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#a6e22e">gulp</span>.<span style="color:#a6e22e">task</span>(<span style="color:#e6db74">&#39;sass&#39;</span>, <span style="color:#66d9ef">function</span>() {
<span style="color:#a6e22e">gulp</span>.<span style="color:#a6e22e">src</span>( <span style="color:#a6e22e">path</span>.<span style="color:#a6e22e">scss</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#39;styles.scss&#39;</span>)
  .<span style="color:#a6e22e">pipe</span>(<span style="color:#a6e22e">maps</span>.<span style="color:#a6e22e">init</span>())
    .<span style="color:#a6e22e">pipe</span>(<span style="color:#a6e22e">sass</span>({ <span style="color:#a6e22e">outputStyle</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;compressed&#39;</span> }))
      .<span style="color:#a6e22e">pipe</span>(<span style="color:#a6e22e">maps</span>.<span style="color:#a6e22e">write</span>())
      .<span style="color:#a6e22e">pipe</span>(<span style="color:#a6e22e">gulp</span>.<span style="color:#a6e22e">dest</span>( <span style="color:#a6e22e">path</span>.<span style="color:#a6e22e">css</span> ))
});

<span style="color:#a6e22e">gulp</span>.<span style="color:#a6e22e">task</span>(<span style="color:#e6db74">&#39;autoprefix&#39;</span>, <span style="color:#66d9ef">function</span>() {
<span style="color:#a6e22e">gulp</span>.<span style="color:#a6e22e">src</span>( <span style="color:#a6e22e">path</span>.<span style="color:#a6e22e">css</span> )
  .<span style="color:#a6e22e">pipe</span>(<span style="color:#a6e22e">prefix</span>(<span style="color:#e6db74">&#39;last 5 versions&#39;</span>, <span style="color:#e6db74">&#39;&gt; 1%&#39;</span>, <span style="color:#e6db74">&#39;ie8&#39;</span>))
  .<span style="color:#a6e22e">pipe</span>(<span style="color:#a6e22e">gulp</span>.<span style="color:#a6e22e">dest</span>( <span style="color:#a6e22e">path</span>.<span style="color:#a6e22e">css</span> ));  
});
</code></pre></div><p>First of all source maps need to be initalized, next a compressed css file from the SCSS files is created, the source
maps are written and we&rsquo;re all good! In a second task Autoprefixer takes the compiled, mapped CSS file and prefixes it
with whatever needs to be prefixed. The output looks like below (look at the right top of each rule set). Click on each
image to view it in full-size.</p>
<!-- raw HTML omitted -->
<p>In case you don&rsquo;t want your source maps in production you could split everything into 3 taks and run them in the order
<code>[&quot;sass&quot;, &quot;sourcemaps&quot;, &quot;autoprefix&quot;]</code> using <code>gulp.task()</code> and then later have the following production task.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#a6e22e">gulp</span>.<span style="color:#a6e22e">task</span>(<span style="color:#e6db74">&#39;production&#39;</span>, [<span style="color:#e6db74">&#39;sass&#39;</span>, <span style="color:#e6db74">&#39;autoprefix&#39;</span>];

<span style="color:#75715e">// Use the following command to keep out Source Maps.
</span><span style="color:#75715e">// $ gulp production
</span></code></pre></div>]]></content><category scheme="https://kevingimbel.de/categories/coding" term="coding" label="coding"/><category scheme="https://kevingimbel.de/categories/nodejs" term="nodejs" label="nodejs"/><category scheme="https://kevingimbel.de/categories/javascript" term="javascript" label="javascript"/><category scheme="https://kevingimbel.de/categories/tools" term="tools" label="tools"/><category scheme="https://kevingimbel.de/tags/gulp" term="gulp" label="gulp"/><category scheme="https://kevingimbel.de/tags/sass" term="sass" label="sass"/><category scheme="https://kevingimbel.de/tags/workflow" term="workflow" label="workflow"/><category scheme="https://kevingimbel.de/tags/productivity" term="productivity" label="productivity"/></entry></feed>